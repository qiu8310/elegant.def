// This file was generated by modules-webmake (modules for web) project.
// See: https://github.com/medikoo/modules-webmake

(function (modules) {
	'use strict';

	var resolve, getRequire, wmRequire, notFoundError, findFile
	  , extensions = {".js":[],".json":[],".css":[],".html":[]}
	  , envRequire = typeof require === 'function' ? require : null;

	notFoundError = function (path) {
		var error = new Error("Could not find module '" + path + "'");
		error.code = 'MODULE_NOT_FOUND';
		return error;
	};
	findFile = function (scope, name, extName) {
		var i, ext;
		if (typeof scope[name + extName] === 'function') return name + extName;
		for (i = 0; (ext = extensions[extName][i]); ++i) {
			if (typeof scope[name + ext] === 'function') return name + ext;
		}
		return null;
	};
	resolve = function (scope, tree, path, fullPath, state, id) {
		var name, dir, exports, module, fn, found, i, ext;
		path = path.split('/');
		name = path.pop();
		if ((name === '.') || (name === '..')) {
			path.push(name);
			name = '';
		}
		while ((dir = path.shift()) != null) {
			if (!dir || (dir === '.')) continue;
			if (dir === '..') {
				scope = tree.pop();
				id = id.slice(0, id.lastIndexOf('/'));
			} else {
				tree.push(scope);
				scope = scope[dir];
				id += '/' + dir;
			}
			if (!scope) throw notFoundError(fullPath);
		}
		if (name && (typeof scope[name] !== 'function')) {
			found = findFile(scope, name, '.js');
			if (!found) found = findFile(scope, name, '.json');
			if (!found) found = findFile(scope, name, '.css');
			if (!found) found = findFile(scope, name, '.html');
			if (found) {
				name = found;
			} else if ((state !== 2) && (typeof scope[name] === 'object')) {
				tree.push(scope);
				scope = scope[name];
				id += '/' + name;
				name = '';
			}
		}
		if (!name) {
			if ((state !== 1) && scope[':mainpath:']) {
				return resolve(scope, tree, scope[':mainpath:'], fullPath, 1, id);
			}
			return resolve(scope, tree, 'index', fullPath, 2, id);
		}
		fn = scope[name];
		if (!fn) throw notFoundError(fullPath);
		if (fn.hasOwnProperty('module')) return fn.module.exports;
		exports = {};
		fn.module = module = { exports: exports, id: id + '/' + name };
		fn.call(exports, exports, module, getRequire(scope, tree, id));
		return module.exports;
	};
	wmRequire = function (scope, tree, fullPath, id) {
		var name, path = fullPath, t = fullPath.charAt(0), state = 0;
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/'];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = '/';
			tree = [];
		} else if (t !== '.') {
			name = path.split('/', 1)[0];
			scope = modules[name];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = name;
			tree = [];
			path = path.slice(name.length + 1);
			if (!path) {
				path = scope[':mainpath:'];
				if (path) {
					state = 1;
				} else {
					path = 'index';
					state = 2;
				}
			}
		}
		return resolve(scope, tree, path, fullPath, state, id);
	};
	getRequire = function (scope, tree, id) {
		return function (path) {
			return wmRequire(scope, [].concat(tree), path, id);
		};
	};
	return getRequire(modules, [], '');
})({
	"elegant.def": {
		"src": {
			"full.js": function (exports, module, require) {
				/**
				 *
				 * 全版本的 def，完全兼容另一个[简版的 def](./simple.js)
				 *
				 * 适合用在代码不需要压缩的地方，比如 node scripts、test scripts 等
				 */

				var base = require('./lib/base'),
				  HereDoc = require('./lib/heredoc'),
				  option = require('./lib/option'),
				  type = require('./lib/type'),
				  Self = require('./lib/self'),
				  Rule = require('./lib/rule');


				function def(fn) {
				  var doc, cfg;

				  if (arguments.length > 1) {
				    return require('./simple').apply(this, arguments);
				  }

				  if (!base.isFunction(fn)) {
				    throw new TypeError('Parameter "' + fn + '" should be function.');
				  }

				  if (false !== (doc = HereDoc.getFromFunc(fn))) {
				    cfg = HereDoc.parse(doc, {rules: Array, options: Object, defaults: Object});
				    cfg.options = base.merge({}, option.all, cfg.options); // clone system options
				    cfg.defaults = base.merge({}, cfg.defaults);
				  }

				  if (!cfg || !cfg.rules || !cfg.rules.length) {
				    //throw new Error('No rules.');
				    return fn;
				  }

				  cfg.rules = base.map(cfg.rules, Rule.parse);
				  //console.log(JSON.stringify(cfg.rules, null, 2));

				  return Self.def(fn, cfg);
				}

				def.option = option;
				base.merge(def, type);

				module.exports = def;
				if (typeof window !== 'undefined') { window.def = def; }
			},
			"lib": {
				"base.js": function (exports, module, require) {
					/**
					 * 由于此组件需要给浏览器用，所以很多函数都是为了兼容各个浏览器
					 *
					 * @module base
					 */

					/**
					 *
					 * @callback IteratorCallback
					 * @param {*} iteratorItem - 遍历对象中的单个元素
					 * @param {Number|String} iteratorKey - 数组的 index 或哈希的 key
					 * @param {Object|Array} ref - 遍历对象本身的引用
					 */

					/**
					 * 遍历一个哈希
					 *
					 * @param {Object} obj
					 * @param {IteratorCallback} fn
					 */
					exports.eachObj = function(obj, fn) {
					  for (var k in obj){
					    if (obj.hasOwnProperty(k)){
					      if (fn(obj[k], k, obj) === false) {
					        break;
					      }
					    }
					  }
					};

					/**
					 * 遍历一个数组
					 *
					 * @param {Array} arr
					 * @param {IteratorCallback} fn
					 */
					exports.eachArr = function(arr, fn) {
					  for (var i = 0; i < arr.length; ++i) {
					    if (fn(arr[i], i, arr) === false) {
					      break;
					    }
					  }
					};

					/**
					 * 返回任意一个 Object 的 type
					 *
					 * @param {*} obj
					 * @returns {String}
					 */
					exports.typeOf = function(obj) {
					  return ({}).toString.call(obj).slice(8, -1).toLowerCase();
					};

					/**
					 * 去除字符串首末的空白字符
					 *
					 * @param {String} str
					 * @returns {String}
					 */
					exports.trim = function(str) {
					  return str.trim ? str.trim() : str.replace(/^\s*|\s*$/g, '');
					};


					/**
					 * 兼容 Array.map
					 *
					 * @param {Array} arr
					 * @param {IteratorCallback} fn
					 * @returns {Array}
					 */
					exports.map = function(arr, fn) {
					  var r = [];
					  return arr.map ?
					    arr.map(fn) :
					    (exports.eachArr(arr, function(){
					      r.push(fn.apply(null, arguments));
					    }) || r);
					};

					/**
					 * 兼容 Array.filter
					 *
					 * @param {Array} arr
					 * @param {IteratorCallback} fn
					 * @returns {Array}
					 */
					exports.filter = function(arr, fn) {
					  var r = [];
					  return arr.filter ?
					    arr.filter(fn) :
					    (exports.eachArr(arr, function(i){
					      if (fn.apply(null, arguments)) {
					        r.push(i);
					      }
					    }) || r);
					};

					/**
					 * 将类似于数组的对象转换成数组
					 *
					 * @param {Object} arrLike
					 * @param {Number} [index = 0]
					 * @returns {Array}
					 */
					exports.arrify = function(arrLike, index) {
					  return [].slice.call(arrLike, index || 0);
					};

					var T = {};

					// 类型检查
					exports.eachArr('Object,Number,String,Array,Boolean,Undefined,Function'.split(','), function(key) {
					  // NaN 不属于上面的任何类型，默认的 typeOf(NaN) 返回的是 number 的，用 mix === mix 把 NaN 过滤掉
					  T['is' + key] = function(mix) { return mix === mix && exports.typeOf(mix) === key.toLowerCase(); };
					});

					/**
					 * 判断一个字符串是否是一个合法的数字
					 *
					 * @param {String} str
					 * @returns {Boolean}
					 */
					exports.isNumerical = function (str) {
					  if (str.charAt(0) === '-') { str = str.substr(1); }

					  if (/^(?:\d*\.)?\d+$/.test(str)) {
					    // 0056, 00.56, 56.00 也会符合正则的
					    if (str.indexOf('.') >= 0) {
					      // 如果小数的第一位是0，则第二位一定要是 . ； 而如果第一位不是 0，则不管 . 在第几位都有效
					      return (str.charAt(0) !== '0') || (str.charAt(1) === '.');
					    } else {
					      return str === '0' || str.charAt(0) !== '0';
					    }
					  }
					  return false;
					};

					/**
					 * 判断一个数字是否是一个合法的整数
					 *
					 * @param {Number} num
					 * @returns {Boolean}
					 */
					exports.isInt = function (num) {
					  return T.isNumber(num) && String(num).indexOf('.') === -1;
					};


					exports.merge = function(to) {
					  if (!to) { to = {}; }
					  exports.eachArr(exports.arrify(arguments, 1), function(arg) {
					    if (T.isObject(arg)) {exports.eachObj(arg, function(v, k) { to[k] = v; });}
					  });
					  return to;
					};

					exports.merge(module.exports, T);

					/**
					 * 取出某个哈希中所有的 key
					 *
					 * @param {Object} obj
					 * @returns {Array}
					 */
					exports.objectKeys = function(obj) {
					  if (Object.keys) {
					    return Object.keys(obj);
					  }
					  var keys = [];
					  exports.eachObj(obj, function(val, key) {
					    keys.push(key);
					  });
					  return keys;
					};

					/**
					 * 保证 str 包含在 { } 内
					 *
					 * @param {String} str
					 * @returns {String}
					 */
					exports.wrapInBrackets = function(str) {
					  if (str.charAt(0) !== '{') {
					    str = '{' + str;
					  }
					  if (str.charAt(str.length - 1) !== '}') {
					    str += '}';
					  }
					  return str;
					};
				},
				"heredoc.js": function (exports, module, require) {
					/**
					 * module HereDoc
					 */

					var jsonfy = require('jsonfy');
					var base = require('./base');

					var HereDoc = {};

					var reDocItem = /^\s*\*\s*@(\w+)\s+(.*?)\s*$/mg;

					/**
					 * 提取 hereDoc 中的关键字段，去掉行首和行尾的空格
					 *
					 * @param {String} hereDocStr
					 * @param {Array} keys
					 * @private
					 */
					function toObject(hereDocStr, keys) {
					  var result = {}, map = {},
					    allKeysMode = !keys.length;

					  base.eachArr(keys, function(it) { map[it.key] = it; });

					  hereDocStr.replace(reDocItem, function(_, key, val) {
					    val = base.trim(val);

					    if (map[key] || allKeysMode) {
					      switch (map[key] && map[key].type) {
					        case Object:
					          if (!base.isObject(result[key])) {
					            result[key] = {};
					          }
					          base.merge(result[key], jsonfy(base.wrapInBrackets(val)));
					          break;

					        case String:
					          result[key] = val;
					          break;

					        default:
					          if (!(key in result)) {
					            result[key] = [];
					          }
					          result[key].push(val);
					      }
					    }
					  });
					  return result;
					}

					/**
					 * 解析 HereDoc 成对象
					 *
					 * @param {String} hereDocStr
					 * @param {*} [keys = null]
					 *
					 */
					HereDoc.parse = function (hereDocStr, keys) {
					  var _keys = [];
					  if (base.isString(keys)) {
					    _keys = [{key: keys, type: Array}];
					  } else if (base.isObject(keys)) {
					    base.eachObj(keys, function(val, key) {
					      _keys.push({key: key, type: val});
					    });
					  } else if (base.isArray(keys)) {
					    base.eachArr(keys, function(val) {
					      _keys.push({key: val, type: Array});
					    });
					  }

					  return toObject(hereDocStr, _keys);
					};

					var reDoc = /(\/\*\*[\s\S]*?\*\/)/;

					/**
					 * 通过 fn.toString() 来得到函数内部定义的 hereDoc
					 *
					 * @param {Function} fn
					 * @returns {String|Boolean}
					 */
					HereDoc.getFromFunc = function(fn) {
					  reDoc.test(fn.toString());
					  return RegExp.$1 || false;
					};

					module.exports = HereDoc;
					if (typeof window !== 'undefined') { window.HereDoc = HereDoc; }
				},
				"option.js": function (exports, module, require) {
					/**
					 * @module option
					 */
					var _opts = {
					  applySelf: false
					};

					/**
					 *
					 * @param {String} key
					 * @param {*} val
					 * @returns {*}
					 */
					function option(key, val) {
					  if (typeof val === 'undefined') {
					    return _opts[key];
					  } else {
					    _opts[key] = val;
					  }
					}

					option.all = _opts;

					module.exports = option;
					if (typeof window !== 'undefined') { window.option = option; }
				},
				"rule-simple.js": function (exports, module, require) {
					var base = require('./base'),
					  type = require('./type');

					module.exports = {
					  /**
					   *
					   * @param {Object} parsedRule
					   * @param {Array} args
					   * @returns {Boolean}
					   */
					  match: function(parsedRule, args) {
					    var result;
					    var argsLen = args.length, okRoad;

					    base.eachArr(parsedRule.roads, function(road, j) {
					      result = {};
					      var roadIndex, argIndex = 0, param, arg;
					      for (roadIndex = 0; roadIndex < road.length; roadIndex++) {
					        param = parsedRule.params[road[roadIndex]];
					        arg = args[argIndex];
					        if (!type.is(arg, param.type) || argIndex >= argsLen) {
					          break;
					        }

					        argIndex++;
					        if (param.rest) {
					          result[param.key] = [arg];
					          while (argIndex < argsLen && type.is(args[argIndex], param.type)) {
					            result[param.key].push(args[argIndex]);
					            argIndex++;
					          }
					        } else {
					          result[param.key] = arg;
					        }
					      }

					      if (argIndex === argsLen && roadIndex === road.length) {
					        okRoad = road;
					        return false;
					      }
					    });

					    return okRoad ? result : false;
					  },

					  /**
					   * 解压缩 rule
					   * @param {Array} compressedRule
					   * @returns {{returnType: *, params: Array, roads: *}}
					   */
					  decompress: function(compressedRule) {
					    return {
					      returnType: compressedRule[0],
					      params: base.map(compressedRule[1], function(group) {
					        if (group[0] !== 1) { group.unshift(0); }
					        var rtn = {key: group[1], type: group[2], rest: group[0]};
					        if (group.length > 3) { rtn.val = group[3]; }
					        return rtn;
					      }),
					      roads: compressedRule[2]
					    };
					  }
					};
				},
				"rule.js": function (exports, module, require) {
					/**
					 * @module rule
					 */

					var base = require('./base');
					var type = require('./type');
					var RuleSimple = require('./rule-simple');
					var jsonfy = require('jsonfy');
					var scan = require('sscan');
					var Rule = {};

					var reRule = /\(([^\)]*)\)\s*->\s*(\*|\w+)/;   // ( ... ) -> type
					//var reArg = /(\w+|\*)\s+((?:\.\.\.)?\w+)\s*(?:=(.*?))?\s*(?=[,\[\]\s]*(?:[\*\w]+\s+(?:\.\.\.)?\w+|$))/g;
					//var reArg = /(\w+|\*)\s+(\w+)\s*(?:=\s*<(.*?)>\s*)?\s*(?=[,\[\]\s]*(?:[\*\w]+\s+\w+|$))/g;
					var reComma = /\s*,\s*/g;

					base.merge(Rule, RuleSimple);

					/**
					 *
					 * - 遇到 '['，到对应的 ']' 中的内容有两种选择，要或者不要
					 * - 遇到非 '['，添加到 prefix
					 *
					 * @param {String} prefix
					 * @param {String} rest
					 * @param {Function} cb
					 * @private
					 */
					function consume(prefix, rest, cb) {
					  if (rest === '') { return cb(prefix); }

					  var index = rest.indexOf('[');
					  if (index < 0) {
					    return cb(prefix + rest);

					  } else if (index === 0) {
					    var count = 0, c, i;
					    for (i = 1; i < rest.length; i++) {
					      c = rest.charAt(i);
					      if (c === '[') {
					        count++;
					      } else if (c === ']') {
					        if (count === 0) {
					          consume(prefix, rest.substr(i + 1), cb);
					          consume(prefix, rest.substring(index + 1, i) + rest.substr(i + 1), cb);
					        } else {
					          count--;
					        }
					      }
					    }

					  } else {
					    consume(prefix + rest.substring(0, index), rest.substr(index), cb);
					  }
					}


					/**
					 * 字符串中是否有成对的 [, ]
					 * @param {String} str
					 * @returns {Boolean}
					 * @private
					 */
					function isBracketsPaired(str) {
					  var count = 0, i, c;
					  for (i = 0; i < str.length; i++) {
					    c = str.charAt(i);
					    if (c === '[') { count++; }
					    if (c === ']') { count--; }
					  }
					  return count === 0;
					}

					function toInt(str) { return parseInt(str, 10); }

					function parseVal(val) {
					  val = val.trim();
					  if (val.charAt(0) === '<' && val.charAt(val.length - 1) === '>') {
					    val = val.substr(1, val.length - 2);
					  }
					  return jsonfy(val);
					}

					// args before :  "* start, [int ...length, int step = 1 ]"
					// args after :   "0, [1, 2]"
					function _parseRuleArgs(args) {
					  var tpl = '', params = [], count = 0;

					  scan(args, function(end) {

					    this.white();
					    if (this.eos()) { end(); }

					    var param = {};

					    tpl += this.till(/[\[\s]/, /[\w\*]/);

					    if (this.isChar('*')) {
					      param.type = '*';
					      this.next('*');
					    } else {
					      param.type = this.takeWord();
					    }

					    this.next(/\s/);
					    this.white();

					    if (this.isChar('.')) {
					      this.next('.');
					      this.next('.');
					      this.next('.');
					      param.rest = 1;
					    } else {
					      param.rest = 0;
					    }
					    param.key = this.takeWord();

					    tpl += count++;

					    tpl += this.till(/[\s\[\]]/, ',=', function(rest) {
					      tpl += rest;
					      params.push(param); end();
					    });

					    if (this.isChar('=')) {
					      this.next('=');
					      this.white();
					      if (this.isChar('"\'[{')) {
					        param.val = this.takeValue();
					      } else if (this.isChar('<')) {
					        param.val = this.takePair('<', '>'); // 为了兼容早期的正则表达式版本
					      } else {
					        param.val = base.trim(this.take(/[^\[\],]/));
					      }
					    }

					    params.push(param);

					    tpl += this.take(/[,\]\[\s]/);

					    if (this.eos()) {
					      end();
					    }
					  });

					  return {tpl: tpl, params: params};
					}


					/**
					 * 解析 HereDoc 中的一条 @rules 定义的规则
					 *
					 * @param {String} rule
					 * @returns {{returnType: string, params: Array, roads: Array}}
					 */
					Rule.parse = function(rule) {

					  if (!reRule.test(rule)) {
					    throw new SyntaxError('Rule "' + rule + '" defined error.');
					  }

					  var args = base.trim(RegExp.$1), parsedArgs,
					    roads = [], result, keyMap = {};

					  result = {
					    returnType: RegExp.$2.toLowerCase(),
					    roads: roads
					  };

					  // args before :  "int start, [int length, int step = 1 ]"
					  // args after :   "0, [1, 2]"
					  try {
					    parsedArgs = _parseRuleArgs(args);
					  } catch (e) {
					    throw new Error('Parse rule arguments error: ' + args);
					  }

					  args = parsedArgs.tpl;
					  base.eachArr(parsedArgs.params, function(param) {
					    if (keyMap[param.key]) { throw new SyntaxError('Duplicate key ' + param.key); }
					    keyMap[param.key] = true;

					    if (!base.isUndefined(param.val)) {
					      param.type = param.type.toLowerCase();

					      try {
					        param.val = parseVal(param.val);
					      } catch (e) {
					        throw new SyntaxError('Rule "' + rule + '" value "' + param.val + '" parsed error.');
					      }

					      if (!type.is(param.val, param.type)) {
					        throw new SyntaxError(param.key + '\'s value is not type ' + param.type);
					      }
					    }
					  });

					  result.params = parsedArgs.params;

					  // 去掉所有的 ','
					  args = args.replace(reComma, ' ');

					  // 确保 [ 和 ] 的个数是一样的
					  if (!isBracketsPaired(args)) { throw new SyntaxError('Rule "' + rule + '" brackets not paired'); }

					  // 得到所有可能的组合
					  consume('', args, function(r) {
					    r = base.trim(r);
					    if (!r) {
					      roads.push([]);
					    } else {
					      roads.push(base.map(r.split(/\s+/), toInt));
					    }
					  });

					  return result;
					};


					/**
					 * 将 rule 压缩， compiler 中要用
					 * @param {Object} parsedRule
					 * @returns {Array}
					 */
					Rule.compress = function(parsedRule) {
					  var params = base.map(parsedRule.params, function(param) {
					    var rtn = [param.key, param.type];
					    if (param.rest) { rtn.unshift(param.rest); }
					    if ('val' in param) { rtn.push(param.val); }
					    return rtn;
					  });
					  return [parsedRule.returnType, params, parsedRule.roads];
					};


					module.exports = Rule;
					if (typeof window !== 'undefined') { window.Rule = Rule; }
				},
				"self.js": function (exports, module, require) {
					var base = require('./base');
					var Rule = require('./rule-simple');

					/**
					 * @class Self
					 * @param {Object} values
					 * @param {Array} args
					 * @param {Object} $rule
					 * @param {Object} $defaults
					 * @param {Object} $options
					 */
					function Self(values, args, $rule, $defaults, $options) {
					  var dft = base.merge({}, $defaults);
					  base.eachArr($rule.params, function(param) {
					    if ('val' in param) { dft[param.key] = param.val; }
					  });
					  this.values = base.merge(dft, values);
					  this.arguments = args;
					  this.$rule = $rule;
					  this.$defaults = $defaults;
					  this.$options = $options;

					  var self = this;
					  base.eachObj(this.values, function(val, key) {
					    self[key] = val;
					  });
					}

					Self.prototype.$has = function(key) {
					  return (key in this.values);
					};

					Self.prototype.$get = function(key) {
					  return this.values[key];
					};

					Self.def = function(fn, cfg) {
					  return function() {
					    var binder = this;
					    var args = base.arrify(arguments), matches = false, rule;

					    // 遍历规则，看是否有匹配的，有的话立即跳出
					    base.eachArr(cfg.rules, function(r) {
					      if ((matches = Rule.match(r, args))) {
					        rule = r;
					        return false;
					      }
					    });

					    // 执行原函数
					    if (matches) {
					      var self = new Self(matches, args, rule, cfg.defaults, cfg.options);
					      if (cfg.options.applySelf) {
					        return fn.apply(self, args);
					      } else {
					        return fn.call(binder, self);
					      }
					    } else {
					      throw new Error('Not found rule for arguments (' + args.join(', ') + ').');
					    }
					  };
					};


					module.exports = Self;
					if (typeof window !== 'undefined') { window.Self = Self; }
				},
				"type.js": function (exports, module, require) {
					/**
					 * @module type
					 */

					var base = require('./base');

					var type = {};

					var all = type._all = {};

					var basicTypes = '*,int,number,string,object,array,function,arguments,boolean,null,nature,positive,negative'.split(','),
					  typeAliases = {
					    integer: 'int',
					    signed: 'int',
					    bool: 'boolean',
					    unsigned: 'nature'
					  };

					function is(mix, type) {
					  if (type in typeAliases) {
					    type = typeAliases[type];
					  }

					  switch (type) {
					    case '*':
					      return true;
					    case 'int':
					      return base.isInt(mix);
					    case 'number':
					      return base.isNumber(mix);
					    case 'nature':
					      return base.isInt(mix) && mix >= 0;
					    case 'positive':
					      return base.isInt(mix) && mix > 0;
					    case 'negative':
					      return base.isInt(mix) && mix < 0;

					    //case 'string':
					    //case 'object':
					    //case 'array':
					    //case 'function':
					    //case 'arguments':
					    //case 'boolean':
					    //case 'null':

					    default :
					      return base.typeOf(mix) === type;
					  }
					}

					base.eachArr(basicTypes.concat(base.objectKeys(typeAliases)), function (key) { all[key] = is; });

					/**
					 * 判断 mix 是否是 type 类型
					 * @param {*} mix
					 * @param {String} type
					 * @returns {Boolean}
					 */
					type.is = function(mix, type) {
					  type = type.toLowerCase();

					  if (!(type in all)) {
					    throw new Error('type "' + type + '" not exists.');
					  }

					  return all[type](mix, type);
					};

					/**
					 * 判断是否定义了 type 类型
					 * @param {String} type
					 * @returns {Boolean}
					 */
					type.has = function(type) {
					  return type.toLowerCase() in all;
					};

					/**
					 * 注册新的类型
					 * @param {String} type
					 * @param {Function} fn
					 */
					type.type = function(type, fn) {
					  type = type.toLowerCase();
					  if (type in all) {
					    throw new Error('type "' + type + '" already exists.');
					  }

					  // 恢复默认的类型
					  if (!fn && (typeAliases[type] || basicTypes.indexOf(type))) {
					    fn = is;
					  }

					  all[type] = fn;
					};

					/**
					 * 删除某一类型
					 * @param {String} type
					 */
					type.untype = function(type) {
					  type = type.toLowerCase();

					  if (!(type in all)) {
					    throw new Error('type "' + type + '" not exists.');
					  }

					  delete all[type];
					};

					/**
					 *
					 * @alias untype
					 */
					type.unType = type.untype;

					module.exports = type;
					if (typeof window !== 'undefined') { window.type = type; }
				}
			},
			"simple.js": function (exports, module, require) {
				/**
				 * 简版的 def
				 *
				 * 不支持 heredoc，适合用在代码需要压缩的地方（代码压缩会将 heredoc 给删除了）
				 */

				var base = require('./lib/base');
				var option = require('./lib/option');
				var Rule = require('./lib/rule-simple');
				var type = require('./lib/type');
				var Self = require('./lib/self');

				/**
				 *
				 * @param {Function} fn
				 * @param {Object} cfg
				 * @returns {Function}
				 */
				function def(fn, cfg) {

				  if (!cfg) {
				    return fn;
				  }

				  cfg.rules = base.map(cfg.rules, Rule.decompress);
				  cfg.options = base.merge({}, option.all, cfg.options);
				  cfg.defaults = base.merge({}, cfg.defaults);

				  return Self.def(fn, cfg);
				}

				def.option = option;
				base.merge(def, type);

				module.exports = def;
				if (typeof window !== 'undefined') { window.def = def; }
			}
		}
	},
	"jsonfy": {
		":mainpath:": "src/jsonfy.js",
		"src": {
			"jsonfy.js": function (exports, module, require) {
				/*
				 * jsonfy
				 * https://github.com/qiu8310/jsonfy"
				 *
				 * Copyright (c) 2015 Zhonglei Qiu
				 * Licensed under the MIT license.
				 */

				var jsonfy = (function() {

				  var at,     // The index of the current character
				    ch,     // The current character
				    endChars = ':,}]',
				    words = {'true': true, 'false': false, 'null': null},
				    trim = function(str) { return str.replace(/^\s+|\s+$/g, ''); },
				    escapee = {
				      '"': '"',
				      '\\': '\\',
				      '/': '/',
				      b: '\b',
				      f: '\f',
				      n: '\n',
				      r: '\r',
				      t: '\t'
				    },
				    text,
				    value,  // Place holder for the value function.

				    isNumerical = function (str) {
				      if (str.charAt(0) === '-') { str = str.substr(1); }

				      if (/^(?:\d*\.)?\d+(?:[eE][-+]?\d*)?$/.test(str)) {
				        // 0056, 00.56, 56.00 也会符合正则的
				        if (str.indexOf('.') >= 0) {
				          // 如果小数的第一位是0，则第二位一定要是 . ； 而如果第一位不是 0，则不管 . 在第几位都有效
				          return (str.charAt(0) !== '0') || (str.charAt(1) === '.');
				        } else {
				          return str === '0' || str.charAt(0) !== '0';
				        }
				      }
				      return false;
				    },

				    error = function (m) {
				      // Call error when something is wrong.
				      throw {
				        name: 'SyntaxError',
				        message: m,
				        at: at,
				        text: text
				      };
				    },

				    next = function (c) {

				      // If a c parameter is provided, verify that it matches the current character.

				      if (c && c !== ch) {
				        error('Expected "' + c + '" instead of "' + ch + '"');
				      }

				      // Get the next character. When there are no more characters,
				      // return the empty string.

				      ch = text.charAt(at);
				      at += 1;
				      return ch;
				    },

				    string = function() {
				      var hex,
				        i,
				        string = '',
				        start = ch === '"' || ch === '\'' ? ch : '',
				        uffff;

				      // When parsing for string values, we must look for " and \ characters.

				      if (start) { next(start); }

				      while (ch) {
				        if (start && ch === start) {
				          next();
				          return string;
				        } else if (!start && endChars.indexOf(ch) >= 0) {
				          return trim(string);
				        }

				        if (ch === '\\') {
				          next();
				          if (ch === 'u') {
				            uffff = 0;
				            for (i = 0; i < 4; i += 1) {
				              hex = parseInt(next(), 16);
				              if (!isFinite(hex)) {
				                break;
				              }
				              uffff = uffff * 16 + hex;
				            }
				            string += String.fromCharCode(uffff);
				          } else if (typeof escapee[ch] === 'string') {
				            string += escapee[ch];
				          } else {
				            break;
				          }
				        } else {
				          string += ch;
				        }
				        next();
				      }

				      error('Bad string');
				    },

				  // 字面量，可以是字符串、数值，或 true, false, null
				    literal = function() {
				      var result = '';
				      while (ch && endChars.indexOf(ch) < 0) {
				        result += ch;
				        next();
				      }
				      result = trim(result);
				      if (words.hasOwnProperty(result)) { return words[result]; }
				      if (isNumerical(result)) {
				        return +result;
				      }
				      return result;
				    },

				    array = function() {
				      var array = [];

				      if (ch === '[') {
				        next('[');
				        white();
				        if (ch === ']') {
				          next(']');
				          return array;   // empty array
				        }
				        while (ch) {
				          array.push(value());
				          white();
				          if (ch === ']') {
				            next(']');
				            return array;
				          }
				          next(',');
				          white();
				        }
				      }
				      error('Bad array');
				    },

				    object = function() {
				      var key,
				        object = {};

				      if (ch === '{') {
				        next('{');
				        white();
				        if (ch === '}') {
				          next('}');
				          return object; // empty object
				        }
				        while (ch) {
				          key = string();
				          white();
				          next(':');
				          if (key === '') {
				            error('Empty key');
				          }
				          if (Object.hasOwnProperty.call(object, key)) {
				            error('Duplicate key "' + key + '"');
				          }
				          object[key] = value();
				          white();
				          if (ch === '}') {
				            next('}');
				            return object;
				          }
				          next(',');
				          white();
				        }
				      }
				      error('Bad object');
				    },

				    white = function() {
				      // Skip whitespace.
				      while (ch && ch <= ' ') { next(); }
				    };

				  value = function() {
				    white();
				    switch (ch) {
				      case '{':
				        return object();
				      case '[':
				        return array();
				      case '"':
				      case '\'':
				        return string();
				      default:
				        return literal();
				    }
				  };

				  return function (source) {

				    var result;
				    if (typeof source !== 'string') {
				      error('Illegal input');
				    }

				    text = source;
				    at = 0;
				    ch = ' ';
				    result = value();
				    white();
				    if (ch) {
				      error('Syntax error');
				    }

				    return result;
				  };
				})();

				if ( typeof module === 'object' && typeof module.exports === 'object' ) {
				  module.exports = jsonfy;
				if (typeof window !== 'undefined') { window.jsonfy = jsonfy; }
				}
			}
		}
	},
	"sscan": {
		":mainpath:": "src/sscan.js",
		"src": {
			"sscan.js": function (exports, module, require) {
				/*
				 * sscan
				 * https://github.com/qiu8310/sscan
				 *
				 * Copyright (c) 2015 Zhonglei Qiu
				 * Licensed under the MIT license.
				 */


				'use strict';

				(function(undef) {
				  /**
				   * One character
				   *
				   * @typedef {String} Char
				   */

				  /**
				   * Character matcher
				   *
				   * @typedef {String|Function|RegExp} CharMatcher
				   */

				  var rWhite = /\s/,
				    rWord = /\w/,

				    quoteModes = {
				      all: {'"': 1, '\'': 1, match: '"\''},
				      single: {'\'': 1, match: '\''},
				      double: {'"': 1, match: '"'},
				      none: {match: ''}
				    },

				    /**
				     * If the character match the charMatcher
				     *
				     * @param {Char} ch
				     * @param {CharMatcher} charMatcher
				     * @returns {Boolean}
				     * @private
				     * @throws {Error} Will throw an error if charMatcher is not a valid CharMatcher.
				     */
				    match = function(ch, charMatcher) {
				      var type = typeof charMatcher;
				      if (type === 'string') {
				        return charMatcher.indexOf(ch) >= 0;
				      } else if (type === 'function') {
				        return charMatcher(ch);
				      } else if (charMatcher instanceof RegExp) {
				        return charMatcher.test(ch);
				      } else {
				        throw new Error('Character matcher "' + charMatcher + '" not acceptable.');
				      }
				    };


				  /**
				   * Scanner constructor
				   *
				   * @param {String} str
				   * @constructor
				   */
				  function Scanner(str) {
				    /**
				     * Original str
				     * @type {String}
				     */
				    this.str = str;

				    /**
				     * Current scan position
				     * @type {Number}
				     */
				    this.pos = 0;

				    /**
				     * Original str length
				     * @type {Number}
				     */
				    this.len = str.length;

				    ///**
				    // * Last matched string
				    // * @type {Object}
				    // */
				    //this.lastMatch = {
				    //  reset: function() {
				    //    this.str = null;
				    //    this.captures = [];
				    //    return this;
				    //  }
				    //}.reset();
				  }

				  Scanner.prototype = {
				    /**
				     * If is the begin of string.
				     * @returns {Boolean}
				     */
				    bos: function() {
				      return this.pos === 0;
				    },

				    /**
				     * If is the end of string.
				     * @param {CharMatcher} [acceptableMatcher]
				     * @returns {Boolean}
				     */
				    eos: function(acceptableMatcher) {
				      if (acceptableMatcher) {
				        var i, rest = this.peekRest();
				        for (i = 0; i < rest.length; i++) {
				          if (!match(rest.charAt(i), acceptableMatcher)) { return false; }
				        }
				        return true;
				      }
				      return this.pos === this.len;
				    },

				    /**
				     * Reset the position.
				     */
				    reset: function() {
				      this.pos = 0;
				    },

				    /**
				     * Throw a SyntaxError.
				     *
				     * @param {String} tpl
				     * @param {String} args...
				     * @private
				     */
				    _syntaxError: function(tpl, args) {
				      args = [].slice.call(arguments, 1);
				      tpl = tpl.replace(/%s/g, function() {
				        return '{{ ' + args.shift() + ' }}';
				      });
				      var err = new SyntaxError(tpl);
				      err.pos = this.pos;
				      err.str = this.str;
				      throw err;
				    },

				    /**
				     * Get current character.
				     * @returns {Char}
				     */
				    char: function() {
				      return this.str.charAt(this.pos);
				    },

				    /**
				     * If current character match the charMatcher.
				     * @param {CharMatcher} charMatcher
				     * @returns {Boolean}
				     */
				    isChar: function(charMatcher) {
				      return match(this.char(), charMatcher);
				    },

				    /**
				     * Get next character
				     * @param {CharMatcher} [charMatcher]
				     * @returns {Char}
				     * @throws {Error} Will throws if already in the end.
				     * @throws {SyntaxError} Will throws if matcher doesn't match current character.
				     */
				    next: function(charMatcher) {
				      if (charMatcher !== undef && !match(this.char(), charMatcher)) {
				        this._syntaxError('Expect %s, but got %s.', charMatcher, this.char());
				      }
				      if (this.eos()) {
				        throw new Error('EOS');
				      }
				      this.pos++;
				      return this.char();
				    },

				    /**
				     * Take next part string that match the charMatcher, can be empty
				     * @param {CharMatcher} charMatcher
				     * @returns {String}
				     */
				    take: function(charMatcher) {
				      var ch = this.char(), res = '';
				      while (match(ch, charMatcher) && !this.eos()) {
				        res += ch;
				        ch = this.next();
				      }
				      return res;
				    },

				    /**
				     * Take the next word.
				     * @returns {String}
				     */
				    takeWord: function() {
				      var word = this.take(rWord);
				      if (!word) {
				        this._syntaxError('Empty string is not a valid word.');
				      }
				      return word;
				    },

				    /**
				     * Take quotes, object and array.
				     * @param {String} [quoteMode='all'] - single, double, all
				     */
				    takeValue: function(quoteMode) {
				      var ch = this.char();
				      if (ch === '[') {
				        return this.takeArray(quoteMode);
				      } else if (ch === '{') {
				        return this.takeObject(quoteMode);
				      } else if (ch === '"' || ch === '\'') {
				        return this.takeQuote(quoteMode);
				      } else {
				        this._syntaxError('Not a valid value.');
				      }
				    },

				    /**
				     * Take quoted characters.
				     * @param {String} [quoteMode='all'] - single, double, all
				     */
				    takeQuote: function(quoteMode) {
				      var quotes = quoteModes[quoteMode] || quoteModes.all;
				      var lastQuote = this.char();
				      var result = lastQuote, ch = this.next(quotes.match);

				      while (lastQuote) {
				        if (ch === lastQuote) {
				          lastQuote = null;
				        }
				        result += ch;
				        ch = this.next();
				      }

				      return result;
				    },

				    /**
				     * Take pair things, line {...}, [...]
				     *
				     * @param {Char} left
				     * @param {Char} right
				     * @param {String} [quoteMode='all'] - single, double, all, none
				     */
				    takePair: function(left, right, quoteMode) {
				      var ch = this.next(left);
				      var count = 1, result = left;
				      var quotes = quoteModes[quoteMode] || quoteModes.all;

				      while (count !== 0) {
				        count += left === ch ? 1 : (right === ch ? -1 : 0);

				        if (quotes[ch]) {
				          result += this.takeQuote(quoteMode);
				          ch = this.char();
				        } else {
				          result += ch;
				          ch = this.next();
				        }
				      }
				      return result;
				    },

				    /**
				     * Take javascript object
				     * @param {String} [quoteMode='all']
				     */
				    takeObject: function(quoteMode) {
				      return this.takePair('{', '}', quoteMode);
				    },

				    /**
				     * Take javascript array
				     * @param {String} [quoteMode='all']
				     */
				    takeArray: function(quoteMode) {
				      return this.takePair('[', ']', quoteMode);
				    },

				    /**
				     * Proceed till character match the endMatcher,
				     * if acceptMatcher supplied, then all mid characters should match the acceptMatcher.
				     *
				     * @param {CharMatcher} [acceptMatcher]
				     * @param {CharMatcher} endMatcher
				     * @param {Function} [eosFn]
				     */
				    till: function(acceptMatcher, endMatcher, eosFn) {

				      var args = [].slice.call(arguments);
				      if (args.length === 1) {
				        endMatcher = acceptMatcher;
				        acceptMatcher = eosFn = null;
				      } else if (args.length === 2) {
				        if (typeof args[1] === 'function') {
				          eosFn = args[1];
				          endMatcher = args[0];
				          acceptMatcher = null;
				        }
				      }

				      var ch = this.char();
				      var pass = '';
				      while (!match(ch, endMatcher) && !this.eos()) {
				        if (acceptMatcher && !match(ch, acceptMatcher)) {
				          this._syntaxError('Expect %s, but got %s.', acceptMatcher, ch);
				        }
				        pass += ch;
				        ch = this.next();
				      }
				      if (this.eos() && eosFn) { eosFn(pass); }
				      return pass;
				    },

				    /**
				     * Get peek of the rest string.
				     *
				     * @returns {String}
				     */
				    peekRest: function() {
				      return this.str.substr(this.pos);
				    },

				    /**
				     * Take in all next white spaces.
				     */
				    white: function() {
				      return this.take(rWhite);
				    }
				  };

				  /**
				   * @param {String} str
				   * @param {Function} [fn]
				   * @returns {*}
				   */
				  function sscan(str, fn) {
				    var scanner = new Scanner(str);
				    if (typeof fn === 'function') {
				      var done = function() { throw {scanDone: true} };
				      try {
				        while (true) { fn.call(scanner, done); }
				      } catch (e) {
				        if (!e.scanDone) { throw e; }
				      }
				    }
				    return scanner;
				  }

				  sscan.Scanner = Scanner;

				  // Export to window and node
				  if (typeof window !== 'undefined') { window.sscan = sscan; }
				  module.exports = sscan;
				if (typeof window !== 'undefined') { window.sscan = sscan; }

				})();
			}
		}
	}
})("elegant.def/src/full");
